#!/bin/sh
set -eu

err() {
	printf %s\\n >&2 "${0##*/}: $1"
	exit "${2-2}"
}
log() {
	printf %s\\n >&2 "${0##*/}: $1"
}



case $# in 0) err "use --help for usage"; esac

case $1 in --help)
printf %s\\n \
"Usage: ${0#*/} c|x|t <-f hrxfile> [-b boundary] [...files]" \
;
exit; esac

case $1 in [!-]*)  set -- -"$@"; esac # first argument is always an option

OPTIND=1;
unset opt_c opt_x opt_t opt_f opt_f_val opt_b opt_b_val
while getopts cxtvf:b: i; do
	case $i in
		c) opt_c='';;
		x) opt_x='';;
		t) opt_t='';;
		v) opt_v='';;
		f) opt_f=''; opt_f_val=$OPTARG;;
		b) opt_b=''; opt_b_val=$OPTARG;;
		?) exit;
	esac
done
shift $((OPTIND - 1))


# path-character ::= any character other than
# U+0000 through U+001F
#  0 	0 	000 		NUL #  no need to/can't detect, shell scripts does no support it. native shell eror may be printed (if the shell has implemented it)
#  1 	1 	001 		SOH
#  2 	2 	002 		STX
#  3 	3 	003 		ETX
#  4 	4 	004 		EOT
#  5 	5 	005 		ENQ
#  6 	6 	006 		ACK
#  7 	7 	007 		BEL
#  8 	8 	010 		BS
#  9 	9 	011 		TAB
#  10 	A 	012 		LF
#  11 	B 	013 		VT
#  12 	C 	014 		FF
#  13 	D 	015 		CR
#  14 	E 	016 		SO
#  15 	F 	017 		SI
#  16 	10 	020 		DLE
#  17 	11 	021 		DC1
#  18 	12 	022 		DC2
#  19 	13 	023 		DC3
#  20 	14 	024 		DC4
#  21 	15 	025 		NAK
#  22 	16 	026 		SYN
#  23 	17 	027 		ETB
#  24 	18 	030 		CAN
#  25 	19 	031 		EM
#  26 	1A 	032 		SUB
#  27 	1B 	033 		ESC
#  28 	1C 	034 		FS
#  29 	1D 	035 		GS
#  30 	1E 	036 		RS
#  31 	1F 	037 		US
# ,
# DEL U+007F DELETE,
# '/' U+002F SOLIDUS, # used as path separator (wont detect)
# ':' U+003A COLON or
# '\' U+005C REVERSE SOLIDUS
path_chars_blacklist=$(
printf \
\\x01\
\\x02\
\\x03\
\\x04\
\\x05\
\\x06\
\\x07\
\\x08\
\\x09\
\\x0A\
\\x0B\
\\x0C\
\\x0D\
\\x0E\
\\x0F\
\\x10\
\\x11\
\\x12\
\\x13\
\\x14\
\\x15\
\\x16\
\\x17\
\\x18\
\\x19\
\\x1A\
\\x1B\
\\x1C\
\\x1D\
\\x1E\
\\x1F\
\
\\x3A\
\\x5C\
;
)
in_line() {
	printf %s "${1-, }in line $line_num: '$line'"
}

parsing_err() {
	err "parsing error($1)$(in_line)" "${2-4}"
}

# fns:

hrx_is_notnewentry() {
	case $1 in "$boundary"|"$boundary "*)
		return 1
	esac
}

# `entry_type` should always be in (dir|file|comment|x_invalid)
hrx_parse_begin_dir() {
	log "(debug) fn hrx_parse_begin_dir       got: '$1' ${2-}"
}
hrx_parse_begin_file() {
	log "(debug) fn hrx_parse_begin_file      got: '$1' ${2-}"
}
hrx_parse_begin_comment() {
	log "(debug) fn hrx_parse_begin_comment   got: '$1' ${2-}"
}
hrx_parse_begin_x_invalid() {
	log "(debug) fn hrx_parse_begin_x_invalid got: '$1' ${2-}"
}


hrx_parse_end_dir() {
	log "(debug) fn hrx_parse_end_dir         got: '$1' ${2-}"
}
hrx_parse_end_file() {
	log "(debug) fn hrx_parse_end_file        got: '$1' ${2-}"
}
hrx_parse_end_comment() {
	log "(debug) fn hrx_parse_end_comment     got: '$1' ${2-}"
}
hrx_parse_end_x_invalid() {
	log "(debug) fn hrx_parse_end_x_invalid   got: '$1' ${2-}"
}


rx_parse_dir() {
	log "(debug) fn hrx_parse_dir             got: '$1' ${2-}"
}
hrx_parse_file() {
	log "(debug) fn hrx_parse_file            got: '$1' ${2-}"
}
hrx_parse_comment() {
	log "(debug) fn hrx_parse_comment         got: '$1' ${2-}"
}
hrx_parse_x_invalid() {
	log "(debug) fn hrx_parse_x_invalid       got: '$1' ${2-}"
}

_hrx_parse_boundary() {
	case $1 in
		\<=*\>*) ;;
		*) return 1;;
	esac

	_i=${line#?}
	_i=${_i%%\>*}

	case ${_i} in
		''|*[!=]*) return 1;;
		*) boundary=${_i%%\>*}\>
	esac

	_i=\<${_i}\>
	case $line in
		"$_i"*) boundary=$_i;; # found first boundary
		*) parsing_err 1;;
	esac
}

hrx_get_entry_type() {

	# first time needs to get boundary
	case ${boundary+x} in '')
		_hrx_parse_boundary "$line" || { # sets 'boundary'
			err "mallformed entry, can not parse boundary$(in_line)"
		}
	esac

	hrx_get_entry_type() {
		case $line in
			"$boundary") entry_type=comment;;
			"$boundary "*/) entry_type=dir;;
			"$boundary "?*) entry_type=file;;
			"$boundary ")
				log "warning: comment with space before new line / seems like empty path? $(in_line '')"
				entry_type=comment
			;;
			*) parsing_err 2 1;;
		esac

		case ${action-} in dir|file) # parsing+validate var `path`
			path=${line#"$boundary "}
			case $line in "$boundary $path") ;; *)
				parsing_err 3
			esac

			while case $path in /*) ;; *) false; esac; do
				log "note: triming absolute path$(in_line)"
				path=${path#/}
			done

			case $path in
			'../'*|*'/../'*|*'/..'|'..')
				err "relative paths contaning '..' are not allowed, path='$path'"
				;;

			'') # expected when trimming '/'|'///'
				log "empty path, path='$path'$(in_line)"
				entry_type=x_invalid
				;;
			*["$path_chars_blacklist"]*)
				log "note: found disawolled char, path='$path'"
				;;
			esac

		esac

	}
	hrx_get_entry_type "$@"
}

hrx_parser() {
	line_num=0
	while read -r line; do
		line_num=$((line_num + 1))

		case ${entry_type-} in '') ;; *)
			hrx_is_notnewentry "$line" || {
				hrx_parse_end_"$entry_type" "$line"
				entry_type=''
			}
		esac

		
		case ${entry_type-} in '')
			hrx_get_entry_type "$line"
			hrx_parse_begin_"$entry_type" "$line"
			continue
		esac

		# NOTE: `entry_type` should always be in (dir|file|comment|x_invalid)
		hrx_parse_"$entry_type" "$line"

	done

	case ${entry_type-} in '') ;; *)
		hrx_parse_end_"$entry_type" "$line" end
	esac

}




IFS='' # do not trim `read -r line`


case ${opt_b+b} in
	b) boundary=$opt_b_val;;
	*) unset boundary;;
esac

files=0
explisit_dirs=0
main() {
case ${opt_c+c}${opt_x+x}${opt_t+t} in
t)
	log "NOTE: 'hrx -t' is in progress"

	hrx_parser

	#
	;;
c)
	err 'hrx -c : NOT IMPLEMENTED'
	;;
x)
	err 'hrx -x : NOT IMPLEMENTED'
	;;

*)
	err 'specify only one of -c, -x or -t option'
esac
}

case ${opt_f_val-} in -) unset opt_f; esac # if its '-' then same as missing -> read from stdin
# and do not add test for if the stdin is the tty, hrx is human readable and *typeable*

case ${opt_f:+f} in
	f) main "$@" < "$opt_f_val";;
	*) main "$@";;
esac
