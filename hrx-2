#!/bin/sh
set -eu

err() {
	printf %s\\n >&2 "${0##*/}:$1"
	exit "${2-2}"
}
log() {
	printf %s\\n >&2 "${0##*/}: $1"
}



case $# in 0) err "use --help for usage"; esac

case $1 in --help)
printf %s\\n \
"Usage: ${0#*/} c|x|t <-f hrxfile> [-b boundary] [...files]" \
;
exit; esac

case $1 in [!-]*)  set -- -"$@"; esac # first argument is always an option

OPTIND=1;
unset opt_c opt_x opt_t opt_f opt_f_val opt_b opt_b_val
while getopts cxtvf:b: i; do
	case $i in
		c) opt_c='';;
		x) opt_x='';;
		t) opt_t='';;
		v) opt_v='';;
		f) opt_f=''; opt_f_val=$OPTARG;;
		b) opt_b=''; opt_b_val=$OPTARG;;
		?) exit;
	esac
done
shift $((OPTIND - 1))



# fns:
when_empty_archivefile() {
	case ${1+x} in
		x) err "archive file is empty" "$1";;
		*) log "archive file is empty";;
	esac
}

# parging fns:
case ${opt_v+v} in
v)
	hrx_parse_comment() {
		printf %s\\n "comment:"
		while read -r line; do
			case $line in
				"$boundary"|"$boundary "*) break;;
				*) printf '  %s\n' "$line";;
			esac
		done
	}
	;;
*)
	hrx_parse_comment() {
		while read -r line; do
			case $line in
				"$boundary"|"$boundary "*) break;;
			esac
		done
	}
esac

##hrx_parse_entry_test() {
##	# note: $line var could already be set by fn `hrx_parse_first_boundary`
##
##	case ${line+x} in '') read -r line; esac
##	while :; do
##		err 'TODO HERE' # TODO:! HERE
##		case $line in
##			"$boundary") err TODO;;
##			""*) err 'parse_name not done'
##		esac
##
##		read -r line || break
##	done
##}

hrx_next_path() {
	case ${1-0} in
		#1) ;; # use previous var `line` as is
		0) read -r line;;
	esac
	while :; do
		case $line in
			"$boundary") hrx_parse_comment || return; continue;; # hrx_parse_comment reads next lines
			"$boundary "*) path=${line#"$boundary"};;
			*) err "parse err in line: $line";;
		esac
		break
	done
}

_hrx_parse__boundary_line() {
	# requires var `line`
	# sets var `boundary` or returns 1 or if parsing error throws `err`
	# temp vars: `_i`

	case $line in
		\<=*\>*) ;;
		*) return 1;;
	esac

	_i=${line#?}
	_i=${_i%%\>*}

	case ${_i} in
		''|*[!=]*) return 1;;
		*) boundary=${_i%%\>*}\>
	esac

	_i=\<${_i}\>
	case $line in
		"$_i"|"$_i "*) boundary=$_i;; # found first boundary
		*) err "parsing error in line: $line" 4;;
	esac
}
hrx_parse_first_boundary() { # seems to work
	# reads untill finds first  boundary
	# note: if first entry is a comment x_path will be unset
	# note: if empty input / cant find line with boundary, then boundary will be unset
	# note: will leave $line var to be parsed later on by *(todo fn name)*

	while read -r line; do
		if _hrx_parse__boundary_line "$line"; then
			break
		else
			log "warning: unexpected line: $line"
		fi
	done
}




IFS='' # do not trim `read -r line`


case ${opt_b+b} in
	b) boundary=$opt_b_val;;
	*) unset boundary;;
esac

files=0
explisit_dirs=0
main() {
case ${opt_c+c}${opt_x+x}${opt_t+t} in
t)
	err 'hrx -t : NOT IMPLEMENTED, {in progress}'
	#
	case ${opt_b+b} in '')
		# reads first line(s) untill finds boundary
		# then sets vars `line` `boundary`
		hrx_parse_first_boundary || return
	esac

	
	###todo: case $# in
	hrx_next_path
	###todo: esac



	#
	;;
c)
	err 'hrx -c : NOT IMPLEMENTED'
	;;
x)
	err 'hrx -x : NOT IMPLEMENTED'
	;;

*)
	err 'specify only one of -c, -x or -t option'
esac
}

case ${opt_f_val-} in -) unset opt_f; esac # if its '-' then same as missing -> read from stdin
# and do not add test for if the stdin is the tty, hrx is human readable and *typeable*

case ${opt_f:+f} in
	f) main "$@" < "$opt_f_val";;
	*) main "$@";;
esac
